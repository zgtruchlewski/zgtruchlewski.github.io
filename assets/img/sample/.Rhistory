prior(constant(1), class = sd, group = g),
backend = "cmdstanr",
threads = threading(4)
)
q()
library(car)
library(dotwhisker)
library(forward)
library(MASS)
library(stargazer)
library(tikzDevice)
install.packages("forward")
install.packages("dotwhisker")
library(car)
library(dotwhisker)
library(forward)
library(MASS)
library(stargazer)
library(tikzDevice)
install.packages("tikzDevice")
set.seed(20)
x1 = rnorm(20, mean=20, sd=3)
y1 = 5 + .5*x1 + rnorm(20)
x2 = c(x1, 30);        y2 = c(y1, 20.8)
x3 = c(x1, 19.44);     y3 = c(y1, 20.8)
x4 = c(x1, 30);        y4 = c(y1, 10)
par(bty="n" , mar=c(2,2,1,0.5), mfrow=c(1,2))
reg1 <- lm(y1 ~ x1)
plot(x1, y1, col=ifelse(x1==20.08467, "red", "black"))
abline(reg1)
plot(reg1, 5)
influencePlot(reg1)
reg1 <- lm(prestige ~ education + income, data= Duncan)
summary(reg1)
influenceIndexPlot(reg1, bty="n")
influencePlot(reg1, bty="n", ylim=c(-3,3.5))
q()
library(ndtv)
install.packages("ndtv")
library(ndtv)
data(short.stergm.sim)
proximity.timeline(short.stergm.sim,default.dist = 6,
mode = 'sammon',labels.at = 17,vertex.cex = 4)
View(short.stergm.sim)
net.sym <- as.undirected(net, mode = "collapse",
edge.attr.comb = list(weight = "sum", "ignore"))
# Rewiring
net.sym.rewired <- rewire(net.sym, each_edge(prob = 0.1))
net.sym.rewired
plot(net.sym.rewired, vertex.size = 10, vertex.label = NA)
q()
install.packages("languageserver")
q()
# load the distance matrix
library(rethinking)
data(islandsDistMatrix)
# display (measured in thousands of km)
Dmat <- islandsDistMatrix
colnames(Dmat) <- c("Ml","Ti","SC","Ya","Fi","Tr","Ch","Mn","To","Ha")
round(Dmat,1)
data(Kline2) # load the ordinary data, now with coordinates
d <- Kline2
d$society <- 1:10 # index observations
dat_list <- list(
T = d$total_tools,
P = d$population,
society = d$society,
Dmat=islandsDistMatrix )
tic()
m1 <- ulam( alist(
T ~ dpois(lambda),
lambda <- (a*P^b/g)*exp(k[society]),
vector[10]:k ~ multi_normal( 0 , SIGMA ),
matrix[10,10]:SIGMA <- cov_GPL2( Dmat , etasq , rhosq , 0.01 ),
c(a,b,g) ~ dexp( 1 ),
etasq ~ dexp( 2 ),
rhosq ~ dexp( 0.5 )),
data=dat_list , chains=4 , cores=4 , iter=2000 )
toc()
library(tictoc)
options(mc.cores = parallel::detectCores())
rstan_options(auto_write = TRUE)
options(digits=2)
set.seed(123456)
library(rethinking)
library(tictoc)
set.seed(1234)
N <- 1e6
x <- rnorm(N)
m <- 1 + rpois(N,2)
y <- rbinom( N , size=m , prob=inv_logit(-3+x) )
dat <- list( y=y , x=x , m=m )
# normal: 49.465 sec elapsed
tic()
m0 <- ulam(alist(
y ~ binomial_logit( m , logit_p ),
logit_p <- a + b*x,
a ~ normal(0,1.5),
b ~ normal(0,0.5)
) , data=dat  )
toc()
library(rethinking)
library(tictoc)
set.seed(1234)
N <- 1e3
x <- rnorm(N)
m <- 1 + rpois(N,2)
y <- rbinom( N , size=m , prob=inv_logit(-3+x) )
dat <- list( y=y , x=x , m=m )
# normal: 49.465 sec elapsed
tic()
m0 <- ulam(alist(
y ~ binomial_logit( m , logit_p ),
logit_p <- a + b*x,
a ~ normal(0,1.5),
b ~ normal(0,0.5)
) , data=dat  )
toc()
data(islandsDistMatrix)
# display (measured in thousands of km)
Dmat <- islandsDistMatrix
colnames(Dmat) <- c("Ml","Ti","SC","Ya","Fi","Tr","Ch","Mn","To","Ha")
round(Dmat,1)
data(Kline2) # load the ordinary data, now with coordinates
d <- Kline2
d$society <- 1:10 # index observations
dat_list <- list(
T = d$total_tools,
P = d$population,
society = d$society,
Dmat=islandsDistMatrix )
tic()
m1 <- ulam( alist(
T ~ dpois(lambda),
lambda <- (a*P^b/g)*exp(k[society]),
vector[10]:k ~ multi_normal( 0 , SIGMA ),
matrix[10,10]:SIGMA <- cov_GPL2( Dmat , etasq , rhosq , 0.01 ),
c(a,b,g) ~ dexp( 1 ),
etasq ~ dexp( 2 ),
rhosq ~ dexp( 0.5 )),
data=dat_list , chains=4 , cores=4 , iter=2000 )
toc()
tic()
m1 <- ulam( alist(
T ~ dpois(lambda),
lambda <- (a*P^b/g)*exp(k[society]),
vector[10]:k ~ multi_normal( 0 , SIGMA ),
matrix[10,10]:SIGMA <- cov_GPL2( Dmat , etasq , rhosq , 0.01 ),
c(a,b,g) ~ dexp( 1 ),
etasq ~ dexp( 2 ),
rhosq ~ dexp( 0.5 )),
data=dat_list , chains=2 , cores=2 , iter=2000 )
toc()
tic()
m1 <- ulam( alist(
T ~ dpois(lambda),
lambda <- (a*P^b/g)*exp(k[society]),
vector[10]:k ~ multi_normal( 0 , SIGMA ),
matrix[10,10]:SIGMA <- cov_GPL2( Dmat , etasq , rhosq , 0.01 ),
c(a,b,g) ~ dexp( 1 ),
etasq ~ dexp( 2 ),
rhosq ~ dexp( 0.5 )),
data=dat_list )
toc()
library(rethinking)
library(tictoc)
set.seed(1234)
N <- 1e3
x <- rnorm(N)
m <- 1 + rpois(N,2)
y <- rbinom( N , size=m , prob=inv_logit(-3+x) )
dat <- list( y=y , x=x , m=m )
# normal: 49.465 sec elapsed
tic()
m0 <- ulam(alist(
y ~ binomial_logit( m , logit_p ),
logit_p <- a + b*x,
a ~ normal(0,1.5),
b ~ normal(0,0.5)
) , data=dat  )
toc()
tic()
m2 <- ulam(alist(
y ~ binomial_logit( m , logit_p ),
logit_p <- a + b*x,
a ~ normal(0,1.5),
b ~ normal(0,0.5)
) , data=dat ,
cmdstan=TRUE , refresh=1000 )
toc()
tic()
m3 <- ulam(alist(
y ~ binomial_logit( m , logit_p ),
logit_p <- a + b*x,
a ~ normal(0,1.5),
b ~ normal(0,0.5)
) , data=dat ,
cmdstan=TRUE , threads=2 )
toc()
# load the distance matrix
library(rethinking)
library(tictoc)
options(mc.cores = parallel::detectCores())
rstan_options(auto_write = TRUE)
options(digits=2)
set.seed(123456)
data(islandsDistMatrix)
# display (measured in thousands of km)
Dmat <- islandsDistMatrix
colnames(Dmat) <- c("Ml","Ti","SC","Ya","Fi","Tr","Ch","Mn","To","Ha")
round(Dmat,1)
data(Kline2) # load the ordinary data, now with coordinates
d <- Kline2
d$society <- 1:10 # index observations
dat_list <- list(
T = d$total_tools,
P = d$population,
society = d$society,
Dmat=islandsDistMatrix )
tic()
m1 <- ulam( alist(
T ~ dpois(lambda),
lambda <- (a*P^b/g)*exp(k[society]),
vector[10]:k ~ multi_normal( 0 , SIGMA ),
matrix[10,10]:SIGMA <- cov_GPL2( Dmat , etasq , rhosq , 0.01 ),
c(a,b,g) ~ dexp( 1 ),
etasq ~ dexp( 2 ),
rhosq ~ dexp( 0.5 )),
data=dat_list )
toc()
tic()
m2 <- ulam( alist(
T ~ dpois(lambda),
lambda <- (a*P^b/g)*exp(k[society]),
vector[10]:k ~ multi_normal( 0 , SIGMA ),
matrix[10,10]:SIGMA <- cov_GPL2( Dmat , etasq , rhosq , 0.01 ),
c(a,b,g) ~ dexp( 1 ),
etasq ~ dexp( 2 ),
rhosq ~ dexp( 0.5 )),
data=dat_list , chains=4 , cores=4 , iter=2000, cmdstan=TRUE, )
toc()
rm(list = ls())
setwd("/Users/zbigniewtruchlewski/Dropbox/PhD/Publications/ToPublish/GeographyAusterity")
# Load libraries
library(Cairo)
library(dplyr)
library(foreign)
library(ggmap)
library(ggplot2)
library(haven)
library(Imap)
library(maps)
library(pheatmap)
library(RColorBrewer)
library(readstata13)
library(reshape2)
library(rethinking)
library(stargazer)
library(tibble)
library(tile)
library(xtable)
options(mc.cores = parallel::detectCores())
rstan_options(auto_write = TRUE)
options(digits=2)
set.seed(123456)
my.col<-brewer.pal(n=3, name="Dark2")
my.col2<-brewer.pal(n=3, name="Set2")
# Stata data
GP <- read.dta13("Data/GP.dta")
# R data
# load("Data/GP.RData")
# Prepare clean data matrix without missing data
# But say how much missing data there is?
GPtrim <- GP[ , c("cntry", "countryn", "year", "yearid", "alefull_tot",
"alefull_tax", "alefull_spend", "tot_dum", "tax_dum", "spend_dum",
"debt", "deficit", "gdpgr", "eu", "emu", "latam") ]
GPcc <- GPtrim[ complete.cases(GPtrim) , ]
# Standardize predictors
GPcc$debts <- round(scale( GPcc$debt ), 2)
GPcc$deficits <- round(scale( GPcc$deficit ), 2)
GPcc$gdpgrs <- round(scale( GPcc$gdpgr ), 2)
# LAG THE THREE PREDICTORS!
# DESCRIPTIVES: how many episodes of what?
GPcc$tax_dum <- as.numeric(GPcc$alefull_tax > GPcc$alefull_spend)
GPcc$spend_dum <- as.numeric(GPcc$alefull_tax < GPcc$alefull_spend)
sum(GPcc$tot_dum) # 342 austerity episodes
sum(GPcc$tax_dum) # 138 tax hikes
sum(GPcc$spend_dum) # 201 spending cuts
# Per McElreath 2016, mean and variance are almost the same, so we can use Poisson
c( mean(GPcc$tot_dum) , var(GPcc$tot_dum) )
c( mean(GPcc$tax_dum) , var(GPcc$tax_dum) )
c( mean(GPcc$spend_dum) , var(GPcc$spend_dum) )
# Upload all Distance matrices
load("Data/CoordinatesDistMats/coordinates.RData")
load("Data/CoordinatesDistMats/dist_mat_ALL.RData")
load("Data/CoordinatesDistMats/coordinates_ALL.RData")
load("Data/CoordinatesDistMats/dist_mat_ALL.RData")
load("Data/CoordinatesDistMats/INVdist_mat_ALL.RData")
load("Data/CoordinatesDistMats/distradew.RData")
GP_tot_dum_DISTRADE <- map2stan(alist(
tot_dum ~ dbinom( 1 , p ),
logit(p) <- a + a_country[countryn] + a_year[yearid] + Debt*debts + Deficit*deficits + GDP*gdpgrs + EMU*emu,
a_country[countryn] ~ GPL2(dist_mat, etasq, rhosq, sigmasq),
a_year[yearid] ~ dnorm( 0 , sigma_year ),
a ~ dnorm(0,10),
c(Debt,Deficit,GDP,EMU) ~ dnorm(0,1),
sigma ~ dcauchy(0,2),
c(etasq,rhosq,sigmasq) ~ dcauchy(0,1),
sigma_year ~ dcauchy(0,1)
), data=list(
tot_dum=GPcc$tot_dum,
countryn=GPcc$countryn,
yearid=GPcc$yearid,
debts=GPcc$debts,
deficits=GPcc$deficits,
gdpgrs=GPcc$gdpgrs,
emu=GPcc$emu,
dist_mat=distradew),
warmup=2000, iter=1e4, cores=4, chains=4, cmdstan=TRUE,
control=list(adapt_delta=0.9999), WAIC=FALSE)
GP_tot_dum_DISTRADE <- ulam(alist(
tot_dum ~ dbinom( 1 , p ),
logit(p) <- a + a_country[countryn] + a_year[yearid] + Debt*debts + Deficit*deficits + GDP*gdpgrs + EMU*emu,
a_country[countryn] ~ GPL2(dist_mat, etasq, rhosq, sigmasq),
a_year[yearid] ~ dnorm( 0 , sigma_year ),
a ~ dnorm(0,10),
c(Debt,Deficit,GDP,EMU) ~ dnorm(0,1),
sigma ~ dcauchy(0,2),
c(etasq,rhosq,sigmasq) ~ dcauchy(0,1),
sigma_year ~ dcauchy(0,1)
), data=list(
tot_dum=GPcc$tot_dum,
countryn=GPcc$countryn,
yearid=GPcc$yearid,
debts=GPcc$debts,
deficits=GPcc$deficits,
gdpgrs=GPcc$gdpgrs,
emu=GPcc$emu,
dist_mat=distradew),
warmup=2000, iter=1e4, cores=4, chains=4, cmdstan=TRUE,
control=list(adapt_delta=0.9999), WAIC=FALSE)
GP_tot_dum_DISTRADE <- ulam(alist(
tot_dum ~ dbinom( 1 , p ),
logit(p) <- a + a_country[countryn] + a_year[yearid] + Debt*debts + Deficit*deficits + GDP*gdpgrs + EMU*emu,
a_country[countryn] ~ cov_GPL2(dist_mat, etasq, rhosq, sigmasq),
a_year[yearid] ~ dnorm( 0 , sigma_year ),
a ~ dnorm(0,10),
c(Debt,Deficit,GDP,EMU) ~ dnorm(0,1),
sigma ~ dcauchy(0,2),
c(etasq,rhosq,sigmasq) ~ dcauchy(0,1),
sigma_year ~ dcauchy(0,1)
), data=list(
tot_dum=GPcc$tot_dum,
countryn=GPcc$countryn,
yearid=GPcc$yearid,
debts=GPcc$debts,
deficits=GPcc$deficits,
gdpgrs=GPcc$gdpgrs,
emu=GPcc$emu,
dist_mat=distradew),
warmup=2000, iter=1e4, cores=4, chains=4, cmdstan=TRUE,
control=list(adapt_delta=0.9999), WAIC=FALSE)
data(islandsDistMatrix)
# display (measured in thousands of km)
Dmat <- islandsDistMatrix
colnames(Dmat) <- c("Ml","Ti","SC","Ya","Fi","Tr","Ch","Mn","To","Ha")
round(Dmat,1)
data(Kline2) # load the ordinary data, now with coordinates
d <- Kline2
d$society <- 1:10 # index observations
dat_list <- list(
T = d$total_tools,
P = d$population,
society = d$society,
Dmat=islandsDistMatrix )
tic()
m1 <- ulam( alist(
T ~ dpois(lambda),
lambda <- (a*P^b/g)*exp(k[society]),
vector[10]:k ~ multi_normal( 0 , SIGMA ),
matrix[10,10]:SIGMA <- cov_GPL2( Dmat , etasq , rhosq , 0.01 ),
c(a,b,g) ~ dexp( 1 ),
etasq ~ dexp( 2 ),
rhosq ~ dexp( 0.5 )),
data=dat_list )
toc()
m1 <- ulam( alist(
T ~ dpois(lambda),
lambda <- (a*P^b/g)*exp(k[society]),
vector[10]:k ~ multi_normal( 0 , SIGMA ),
matrix[10,10]:SIGMA <- cov_GPL2( Dmat , etasq , rhosq , 0.01 ),
c(a,b,g) ~ dexp( 1 ),
etasq ~ dexp( 2 ),
rhosq ~ dexp( 0.5 )),
data=dat_list, cmdstan=TRUE  )
precis( m1 , depth=3 )
tic()
m1 <- ulam( alist(
T ~ dpois(lambda),
lambda <- (a*P^b/g)*exp(k[society]),
vector[10]:k ~ multi_normal( 0 , SIGMA ),
matrix[10,10]:SIGMA <- cov_GPL2( Dmat , etasq , rhosq , 0.01 ),
c(a,b,g) ~ dexp( 1 ),
etasq ~ dexp( 2 ),
rhosq ~ dexp( 0.5 )),
data=dat_list, cmdstan=TRUE, threads=2  )
toc()
tic()
m1 <- ulam( alist(
T ~ dpois(lambda),
lambda <- (a*P^b/g)*exp(k[society]),
vector[10]:k ~ multi_normal( 0 , SIGMA ),
matrix[10,10]:SIGMA <- cov_GPL2( Dmat , etasq , rhosq , 0.01 ),
c(a,b,g) ~ dexp( 1 ),
etasq ~ dexp( 2 ),
rhosq ~ dexp( 0.5 )),
data=dat_list, cmdstan=TRUE)
toc()
library(dagitty)
library(dagitty)
dag5.1 <- dagitty( "dag{ A -> D; A -> M; M -> D }" )
coordinates(dag5.1) <- list( x=c(A=0,D=1,M=2) , y=c(A=0,D=1,M=0) )
drawdag( dag5.1 )
library(dagitty)
collider <- dagitty( "dag{ A -> C; B -> C }" )
coordinates(dag5.1) <- list( x=c(A=0,C=1,B=2) , y=c(A=0,C=1,B=0) )
drawdag( collider )
library(dagitty)
collider <- dagitty( "dag{ A -> C; A -> B; B -> C }" )
coordinates(dag5.1) <- list( x=c(A=0,C=1,B=2) , y=c(A=0,C=1,B=0) )
drawdag( collider )
library(dagitty)
collider <- dagitty( "dag{ A -> C; A -> B; B -> C }" )
coordinates(dag5.1) <- list( x=c(A=0,C=1,B=2) , y=c(A=0,C=1,B=0) )
drawdag( collider )
library(dagitty)
collider <- dagitty( "dag{ A -> C; A -> B; B -> C }" )
coordinates(dag5.1) <- list( x=c(A=0,C=1,B=2) , y=c(A=0,C=1,B=0) )
drawdag( collider )
library(dagitty)
collider <- dagitty( "dag{ A -> C; A -> B; B -> C }" )
coordinates(dag5.1) <- list( x=c(A=0,C=1,B=2) , y=c(A=0,C=1,B=0) )
drawdag( collider )
library(dagitty)
collider <- dagitty( "dag{ A -> C; A -> B; B -> C }" )
coordinates(dag5.1) <- list( x=c(A=0,C=1,B=2) , y=c(A=0,C=1,B=0) )
drawdag( collider )
library(dagitty)
collider <- dagitty( "dag{ A -> C; A -> B; B -> C }" )
coordinates(dag5.1) <- list( x=c(A=0,C=1,B=2) , y=c(A=0,C=1,B=0) )
drawdag( collider )
library(dagitty)
dag5.1 <- dagitty( "dag{ A -> D; A -> M; M -> D }" )
coordinates(dag5.1) <- list( x=c(A=0,D=1,M=2) , y=c(A=0,D=1,M=0) )
drawdag( dag5.1 )
library(dagitty)
dag5.1 <- dagitty( "dag{ A -> D; A -> M; M -> D }" )
coordinates(dag5.1) <- list( x=c(A=0,D=1,M=2) , y=c(A=0,D=1,M=0) )
drawdag( dag5.1 )
library(dagitty)
dag5.1 <- dagitty( "dag{ A -> D; A -> M; M -> D }" )
coordinates(dag5.1) <- list( x=c(A=0,D=1,M=2) , y=c(A=0,D=1,M=0) )
drawdag( dag5.1 )
library(dagitty)
dag5.1 <- dagitty( "dag{ A -> D; A -> M; M -> D }" )
coordinates(dag5.1) <- list( x=c(A=0,D=1,M=2) , y=c(A=0,D=1,M=0) )
drawdag( dag5.1 )
library(dagitty)
dag5.1 <- dagitty( "dag{ A -> D; A -> M; M -> D }" )
coordinates(dag5.1) <- list( x=c(A=0,D=1,M=2) , y=c(A=0,D=1,M=0) )
drawdag( dag5.1 )
library(dagitty)
collider <- dagitty( "dag{ A -> C; A -> B; B -> C }" )
coordinates(collider) <- list( x=c(A=0,C=1,B=2) , y=c(A=0,C=1,B=0) )
drawdag( collider )
library(dagitty)
collider <- dagitty( "dag{ A -> C; A -> B; B -> C }" )
coordinates(collider) <- list( x=c(A=0,C=1,B=2) , y=c(A=0,C=1,B=0) )
drawdag( collider )
library(dagitty)
collider <- dagitty( "dag{ A -> C; B -> C }" )
coordinates(collider) <- list( x=c(A=0,C=1,B=2) , y=c(A=0,C=1,B=0) )
drawdag( collider )
library(Cairo)
setwd("/Users/zbigniewtruchlewski/Dropbox (Personal)/GitHub/zgtruchlewski.github.io/assets/img/sample")
library(dagitty)
collider <- dagitty( "dag{ A -> C; B -> C }" )
coordinates(collider) <- list( x=c(A=0,C=1,B=2) , y=c(A=0,C=1,B=0) )
cairo_pdf("Collider.pdf" ,width=5,height=5, bg="transparent", family = "Gill Sans MT")
par(mar = c(2.75, 2.75, 2, .25), mgp = c(1.5, .5, 0), oma = c(0.2, 0, 0, 0), col.lab = "black")
drawdag(collider)
dev.off()
cairo_pdf("Collider.pdf" ,width=5,height=3, bg="transparent", family = "Gill Sans MT")
par(mar = c(2.75, 2.75, 2, .25), mgp = c(1.5, .5, 0), oma = c(0.2, 0, 0, 0), col.lab = "black")
drawdag(collider)
dev.off()
cairo_pdf("Collider.pdf" ,width=3,height=1.5, bg="transparent", family = "Gill Sans MT")
par(mar = c(2.75, 2.75, 2, .25), mgp = c(1.5, .5, 0), oma = c(0.2, 0, 0, 0), col.lab = "black")
drawdag(collider)
dev.off()
library(dagitty)
collider <- dagitty( "dag{ A -> Collider; B -> Collider }" )
coordinates(collider) <- list( x=c(A=0,Collider=1,B=2) , y=c(A=0,Collider=1,B=0) )
drawdag( collider )
library(dagitty)
collider <- dagitty( "dag{ A -> Collider; B -> Collider }" )
coordinates(collider) <- list( x=c(A=0,Collider=1,B=2) , y=c(A=0,Collider=1,B=0) )
cairo_pdf("Collider.pdf" ,width=3,height=1.5, bg="transparent", family = "Gill Sans MT")
par(mar = c(2.75, 2.75, 2, .25), mgp = c(1.5, .5, 0), oma = c(0.2, 0, 0, 0), col.lab = "black")
drawdag(collider)
dev.off()
q()
